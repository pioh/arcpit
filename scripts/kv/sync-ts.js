import * as path from "node:path";
import { mkdir, readdir, readFile, rm, writeFile } from "node:fs/promises";
import { existsSync } from "node:fs";

async function ensureEmptyDir(p) {
    await rm(p, { recursive: true, force: true });
    await mkdir(p, { recursive: true });
}

async function* walk(dir) {
    const ents = await readdir(dir, { withFileTypes: true });
    for (const ent of ents) {
        const full = path.join(dir, ent.name);
        if (ent.isDirectory()) yield* walk(full);
        else if (ent.isFile()) yield full;
    }
}

function toPosix(p) {
    return p.replaceAll("\\", "/");
}

function isTsFile(p) {
    return p.endsWith(".ts") && !p.endsWith(".d.ts");
}

function normalizeImportPath(p) {
    const posix = p.replaceAll("\\", "/");
    if (posix.startsWith(".")) return posix;
    return "./" + posix;
}

function rewriteImportsForDst(ts, dstFileAbs, outRootAbs) {
    // Fix relative imports like "../lib/dota_ts_adapter" after moving under src/vscripts/kv_generated/**.
    const dstDir = path.dirname(dstFileAbs);
    const libAbs = path.resolve(outRootAbs, "..", "lib", "dota_ts_adapter");
    const relToLib = normalizeImportPath(path.relative(dstDir, libAbs));

    return ts
        .replaceAll("\"../lib/dota_ts_adapter\"", JSON.stringify(relToLib))
        .replaceAll("\"./lib/dota_ts_adapter\"", JSON.stringify(relToLib))
        .replaceAll("\"../../lib/dota_ts_adapter\"", JSON.stringify(relToLib))
        .replaceAll("\"../../../lib/dota_ts_adapter\"", JSON.stringify(relToLib))
        .replaceAll("\"../../../../lib/dota_ts_adapter\"", JSON.stringify(relToLib));
}

async function main() {
    const args = process.argv.slice(2);
    const kvRootArg = args.find((a) => a.startsWith("--kv="))?.slice("--kv=".length);
    const outArg = args.find((a) => a.startsWith("--out="))?.slice("--out=".length);

    const kvRoot = path.resolve(process.cwd(), kvRootArg ?? "kv");
    const outRoot = path.resolve(process.cwd(), outArg ?? path.join("src", "vscripts", "kv_generated"));

    if (!existsSync(kvRoot)) {
        console.error(`❌ kv root not found: ${kvRoot}`);
        process.exit(1);
    }

    await ensureEmptyDir(outRoot);

    const copied = [];
    for await (const file of walk(kvRoot)) {
        if (!isTsFile(file)) continue;
        const rel = toPosix(path.relative(kvRoot, file));
        // only allow from explicit folders
        if (!(rel.includes("/modifiers/") || rel.includes("/customizers/"))) continue;
        const dst = path.join(outRoot, rel);
        await mkdir(path.dirname(dst), { recursive: true });
        const raw = await readFile(file, "utf8");
        const rewritten = rewriteImportsForDst(raw, dst, outRoot);
        await writeFile(dst, rewritten, "utf8");
        copied.push(rel);
    }

    copied.sort();

    const imports = copied.map((rel) => `import "./${rel.replace(/\.ts$/, "")}";`).join("\n");
    const content =
        `// AUTO-GENERATED by bun run generate (DO NOT EDIT)\n` +
        `// This file exists to pull kv/**/{modifiers,customizers} TS into the compilation + side-effects (modifier registration).\n` +
        (imports ? `${imports}\n` : "") +
        `export {}; \n`;

    await writeFile(path.join(outRoot, "autoload.ts"), content, "utf8");
    console.log(`✓ kv TS synced: ${copied.length} files -> ${outRoot}`);
}

await main();


